package agui_adapter

import (
	"encoding/json"
	"fmt"

	"github.com/ag-ui-protocol/ag-ui/sdks/community/go/pkg/core/events"
)

// Re-export Message type from SDK for convenience (no duplication)
type Message = events.Message

// RunAgentInput represents the AG-UI protocol input format
type RunAgentInput struct {
	ThreadID       string                   `json:"threadId"`
	RunID          string                   `json:"runId"`
	State          map[string]interface{}   `json:"state"`
	Messages       []map[string]interface{} `json:"messages"` // Keep as map for flexibility, but validate structure
	Tools          []interface{}            `json:"tools"`
	Context        []interface{}            `json:"context"`
	ForwardedProps map[string]interface{}   `json:"forwardedProps"`
}

// Validate validates the RunAgentInput structure
// This should be called early in the request flow (in handlers) before processing
func (r *RunAgentInput) Validate() error {
	// ThreadID and RunID are optional (will be generated if missing)
	// State, Tools, Context, and ForwardedProps are optional

	// Validate messages (most important validation)
	if err := ValidateMessages(r.Messages); err != nil {
		return fmt.Errorf("messages validation failed: %w", err)
	}

	return nil
}

// GetThreadID returns the thread ID, generating one if not present
func (r *RunAgentInput) GetThreadID() string {
	if r.ThreadID != "" {
		return r.ThreadID
	}
	// This will be generated by the handler using events.GenerateThreadID()
	return ""
}

// GetRunID returns the run ID, generating one if not present
func (r *RunAgentInput) GetRunID() string {
	if r.RunID != "" {
		return r.RunID
	}
	// This will be generated by the handler using events.GenerateRunID()
	return ""
}

// HasMessages returns true if there are messages in the input
func (r *RunAgentInput) HasMessages() bool {
	return len(r.Messages) > 0
}

// GetState returns the state map, initializing it if nil
func (r *RunAgentInput) GetState() map[string]interface{} {
	if r.State == nil {
		return make(map[string]interface{})
	}
	return r.State
}

// GetTools returns the tools array, initializing it if nil
func (r *RunAgentInput) GetTools() []interface{} {
	if r.Tools == nil {
		return make([]interface{}, 0)
	}
	return r.Tools
}

// GetContext returns the context array, initializing it if nil
func (r *RunAgentInput) GetContext() []interface{} {
	if r.Context == nil {
		return make([]interface{}, 0)
	}
	return r.Context
}

// GetForwardedProps returns the forwarded props map, initializing it if nil
func (r *RunAgentInput) GetForwardedProps() map[string]interface{} {
	if r.ForwardedProps == nil {
		return make(map[string]interface{})
	}
	return r.ForwardedProps
}

// ParseMessage parses a message from map[string]interface{} to Message struct using the SDK's UnmarshalJSON
// This leverages the SDK's built-in JSON unmarshaling which handles content serialization correctly
func ParseMessage(msgMap map[string]interface{}) (*Message, error) {
	if msgMap == nil {
		return nil, fmt.Errorf("message map is nil")
	}

	// Validate required fields first
	if _, ok := msgMap["id"].(string); !ok {
		return nil, fmt.Errorf("message missing required field 'id'")
	}
	if _, ok := msgMap["role"].(string); !ok {
		return nil, fmt.Errorf("message missing required field 'role'")
	}

	// Use JSON marshaling/unmarshaling to leverage SDK's UnmarshalJSON
	jsonData, err := json.Marshal(msgMap)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal message map: %w", err)
	}

	var msg Message
	if err := msg.UnmarshalJSON(jsonData); err != nil {
		return nil, fmt.Errorf("failed to unmarshal message: %w", err)
	}

	return &msg, nil
}
